#!/bin/bash
# Scaling validation script for Todo Chatbot frontend
# Generated by kubectl-ai based on Phase 4 spec

set -e  # Exit on any error

echo "Validating frontend scaling to minimum 2 replicas..."

# Check if kubectl is available
if ! command -v kubectl &> /dev/null; then
    echo "Error: kubectl is not installed"
    exit 1
fi

# Check if Helm is available
if ! command -v helm &> /dev/null; then
    echo "Error: Helm is not installed"
    exit 1
fi

# Set the release name
RELEASE_NAME="todo-chatbot"

# Check if the Helm release exists
if ! helm status $RELEASE_NAME &> /dev/null; then
    echo "Error: Helm release $RELEASE_NAME is not deployed"
    exit 1
fi

echo "Helm release $RELEASE_NAME exists"

# Check if frontend deployment exists
FRONTEND_DEPLOYMENT=$(kubectl get deployments -l app=frontend -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)

if [ -z "$FRONTEND_DEPLOYMENT" ]; then
    echo "Error: Frontend deployment not found"
    exit 1
fi

echo "Frontend deployment found: $FRONTEND_DEPLOYMENT"

# Get replica counts
REQUESTED_REPLICAS=$(kubectl get deployment $FRONTEND_DEPLOYMENT -o jsonpath='{.spec.replicas}')
READY_REPLICAS=$(kubectl get deployment $FRONTEND_DEPLOYMENT -o jsonpath='{.status.readyReplicas}')
AVAILABLE_REPLICAS=$(kubectl get deployment $FRONTEND_DEPLOYMENT -o jsonpath='{.status.availableReplicas}')

echo "Requested replicas: $REQUESTED_REPLICAS"
echo "Ready replicas: $READY_REPLICAS"
echo "Available replicas: $AVAILABLE_REPLICAS"

# Check if we have at least 2 replicas
if [ "$REQUESTED_REPLICAS" -lt 2 ]; then
    echo "‚ùå Frontend deployment has less than 2 requested replicas ($REQUESTED_REPLICAS)"
    exit 1
fi

if [ "$READY_REPLICAS" -lt 2 ]; then
    echo "‚ùå Frontend deployment has less than 2 ready replicas ($READY_REPLICAS)"
    exit 1
fi

if [ "$AVAILABLE_REPLICAS" -lt 2 ]; then
    echo "‚ùå Frontend deployment has less than 2 available replicas ($AVAILABLE_REPLICAS)"
    exit 1
fi

echo "‚úÖ Frontend deployment has at least 2 replicas as required"

# Check actual pod count
POD_COUNT=$(kubectl get pods -l app=frontend --field-selector=status.phase=Running -o json | jq '.items | length' 2>/dev/null)

if [ -z "$POD_COUNT" ]; then
    # If jq is not available, count differently
    POD_COUNT=$(kubectl get pods -l app=frontend --field-selector=status.phase=Running -o name | wc -l)
fi

echo "Running frontend pods: $POD_COUNT"

if [ "$POD_COUNT" -lt 2 ]; then
    echo "‚ùå Less than 2 frontend pods are running ($POD_COUNT)"
    exit 1
fi

echo "‚úÖ At least 2 frontend pods are running"

# Check if pods are evenly distributed (if possible)
echo "Checking pod distribution..."
FRONTEND_PODS=$(kubectl get pods -l app=frontend --field-selector=status.phase=Running -o jsonpath='{.items[*].metadata.name}')

for pod in $FRONTEND_PODS; do
    NODE_NAME=$(kubectl get pod $pod -o jsonpath='{.spec.nodeName}')
    echo "  Pod $pod running on node $NODE_NAME"
done

# Check service endpoints to confirm load balancing
echo "Checking service endpoints for load balancing..."
FRONTEND_SERVICE=$(kubectl get svc -l app=frontend -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)

if [ -n "$FRONTEND_SERVICE" ]; then
    ENDPOINT_COUNT=$(kubectl get endpoints $FRONTEND_SERVICE -o jsonpath='{range .subsets[0].addresses[*]}{.ip}{" "}{end}' | wc -w)
    echo "Service endpoints: $ENDPOINT_COUNT"
    
    if [ "$ENDPOINT_COUNT" -ge 2 ]; then
        echo "‚úÖ Service has multiple endpoints for load balancing"
    else
        echo "‚ö†Ô∏è  Service has only $ENDPOINT_COUNT endpoint(s) for load balancing"
    fi
else
    echo "‚ö†Ô∏è  Could not find frontend service for endpoint check"
fi

# Check resource allocation per pod
echo "Checking resource allocation per pod..."
for pod in $FRONTEND_PODS; do
    REQUESTS_CPU=$(kubectl get pod $pod -o jsonpath='{.spec.containers[0].resources.requests.cpu}')
    REQUESTS_MEMORY=$(kubectl get pod $pod -o jsonpath='{.spec.containers[0].resources.requests.memory}')
    LIMITS_CPU=$(kubectl get pod $pod -o jsonpath='{.spec.containers[0].resources.limits.cpu}')
    LIMITS_MEMORY=$(kubectl get pod $pod -o jsonpath='{.spec.containers[0].resources.limits.memory}')
    
    echo "  Pod $pod: requests={CPU:$REQUESTS_CPU, Memory:$REQUESTS_MEMORY}, limits={CPU:$LIMITS_CPU, Memory:$LIMITS_MEMORY}"
done

# Test scaling functionality by temporarily scaling up
echo "Testing scaling functionality..."
CURRENT_REPLICAS=$REQUESTED_REPLICAS
TARGET_REPLICAS=$((CURRENT_REPLICAS + 1))

echo "Temporarily scaling frontend to $TARGET_REPLICAS replicas to test scaling functionality..."
kubectl scale deployment $FRONTEND_DEPLOYMENT --replicas=$TARGET_REPLICAS

# Wait for scaling to happen
sleep 10

# Check if scaling worked
NEW_READY_REPLICAS=$(kubectl get deployment $FRONTEND_DEPLOYMENT -o jsonpath='{.status.readyReplicas}')
if [ "$NEW_READY_REPLICAS" -ge "$TARGET_REPLICAS" ]; then
    echo "‚úÖ Scaling test successful - deployment reached $NEW_READY_REPLICAS replicas"
else
    echo "‚ö†Ô∏è  Scaling test showed only $NEW_READY_REPLICAS/$TARGET_REPLICAS replicas ready"
fi

# Scale back to original count
echo "Scaling back to original count ($CURRENT_REPLICAS)..."
kubectl scale deployment $FRONTEND_DEPLOYMENT --replicas=$CURRENT_REPLICAS

echo ""
echo "üéâ Frontend scaling validation completed!"
echo "‚úÖ Deployment name: $FRONTEND_DEPLOYMENT"
echo "‚úÖ Requested replicas: $REQUESTED_REPLICAS (minimum 2 required)"
echo "‚úÖ Ready replicas: $READY_REPLICAS (minimum 2 required)"
echo "‚úÖ Available replicas: $AVAILABLE_REPLICAS (minimum 2 required)"
echo "‚úÖ Running pods: $POD_COUNT (minimum 2 required)"
echo ""
echo "Frontend is properly scaled with high availability."